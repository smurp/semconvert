#!/usr/bin/env node

const { program } = require('commander');
const fs = require('fs');
const mime = require('mime');
const { Parser, Writer, Store } = require('n3');
const path = require('path');

function ensure_mimetypes(map) {
  for (var type in map) {
    var exts = map[type];
    if (! mime.extensions[type]) {
      mime.define(map);
    }
  }
}
ensure_mimetypes({'application/n-quads':['nq'],
                  'application/n-triples':['nt'],
                  'application/trig':['trig'],
                  'application/trig+star':['trig','trig+star'],
                  'application/rdf+star': ['rdf','rdf+star'],
                  'application/ttl+star': ['ttl','ttl+star'],
                  'application/n-quads+star': ['nq','nq+star'],
                  'text/n3': ['n3'],
                  'application/vnd.org-mode': ['org'],
                  'application/json': ['json'],
                  'text/csv': ['csv'],
                  'text/tab-separated-values': ['tsv'] // also 'tab'
                 })

class UniqueArray extends Array {
  pushIndexOf(key) {
    if (this.indexOf(key)==-1) {
      this.push(key);
    }
    return this.indexOf(key);
  }
}

class TableWriter {
  constructor(options={}) {
    this.options = options;
    this.store = new Store();
    this.line_prefix = '';
    this.line_postfix = '';
    this.col_delim = '';
    this.col_prefix = '';
    this.col_postfix = '';
  }
  addQuad(quad) {
    this.store.addQuad(quad);
  }
  addPrefixes(prefixes) {
    this.store.add(prefixes);
  }
  stripUrl(urlStr) {
    const url = new URL(urlStr);
    return url.hash.replace('#','')      // the hash WITHOUT the octothorp
      || url.pathname.split('/').at(-1)  // the last part of the path
      || url.hostname;                   // the hostname
  }
  disciplineSubject(subj) {
    return this.options.stripUrls ? this.stripUrl(subj.value) : subj.value;
  }
  disciplinePredicate(pred) {
    return this.options.stripUrls ? this.stripUrl(pred.value) : pred.value;
  }
  getChart() {
    let labels = new UniqueArray();
    let chart = {datasets: []}
    for (const subj of this.store.getSubjects()) {
      if (subj.value == '') continue; // skips DefaultGraph
      let row = {label:this.disciplineSubject(subj), data:[]};
      for (const pred of this.store.getPredicates(subj, null, null)) {
        if (pred.value == '') continue; // skips DefaultGraph
        var cookedPred = this.disciplinePredicate(pred);
        var colIdx = labels.pushIndexOf(cookedPred);
        for (const quad of this.store.getQuads(subj, pred, null)) {
          row.data[colIdx] = quad.object.value;
        }
      }
      chart.datasets.push(row);
    }
    chart.labels = Array.from(labels.values());
    return chart;
  }
  makeLine(vals) {
    // this really should iterate through the values so they can be escaped!!!
    return this.line_prefix
      + (vals.length ? this.col_prefix : '')  // only if there are vals
      + vals.join(this.col_prefix + this.col_delim + this.col_postfix)
      + (vals.length ? this.col_postfix : '') // only if there are vals
      + this.line_postfix
      + "\n";
  }
  decorateTable() {
    let chart = this.getChart();
    let table = this.makeLine([''].concat(chart.labels));
    for (const row of chart.datasets) {
      table += this.makeLine([row.label].concat(row.data));
    }
    return table;
  }
  end(cb) {
    let error;
    let result = this.decorateTable();
    cb(error, result);
  }
  FUTURE__get_or_make_id_for_quad(quad) {
    return [quad.subject, quad.predicate, quad.object].join(' ');
  }
}
class ChartData extends TableWriter {
  decorateTable() {
    return JSON.stringify(this.getChart(), null, 4);
  }
}
class OrgModeTable extends TableWriter {
  constructor(options={}) {
    super(options);
    this.line_prefix = '|';
    this.line_postfix = '|';
    this.col_delim = '|';
  }
}
class TabSeparatedTable extends TableWriter {
  constructor(options={}) {
    super(options);
    this.col_delim = "\t";
  }
}
class CommaSeparatedTable extends TableWriter {
  constructor(options={}) {
    super(options);
    this.col_delim = ',';
    this.col_prefix = '"';
    this.col_postfix = '"';
  }
}

function ruleApplies(passOrDenyRegexList, value) {
  for (const re of passOrDenyRegexList) {
    const regex = new RegExp(re);
    if (regex.test(value)) return true;
  }
  return false;
}

function isQuadPermitted(quad, options) {
  const {denySubjLike, passSubjLike, passPredLike, denyPredLike} = options;
  if (denySubjLike || passSubjLike || passPredLike || denyPredLike ) {
    if (denySubjLike
        && ruleApplies(denySubjLike, quad.subject.value)) return false;
    if (denyPredLike
        && ruleApplies(denyPredLike, quad.predicate.value)) return false;
    if (passSubjLike
        && ! ruleApplies(passSubjLike, quad.subject.value)) return false;
    if (passPredLike
        && ! ruleApplies(passPredLike, quad.predicate.value)) return false;
  }
  return true; // quads are permitted by default
}

function semconvert(infile, outfile, options) {
  // parameter > extension > default
  const {verbose, noprefix, informat, outformat, dryrun, stripUrls} = options;
  const inputFormat = (informat && mime.lookup(informat))
    || (infile!='-' && mime.lookup(infile))
    || 'text/turtle';
  const outputFormat = (outformat && mime.lookup(outformat))
    || (outfile!='-' && mime.lookup(outfile))
    || 'text/turtle';

  // prepare parser and writer
  const parser = new Parser({ format: inputFormat });
  const tableWriterOptions = {stripUrls};
  let writer;
  switch (outputFormat) {
  case 'application/vnd.org-mode':
    writer = new OrgModeTable(tableWriterOptions);
    break;
  case 'text/tab-separated-values':
    writer = new TabSeparatedTable(tableWriterOptions);
    break;
  case 'text/csv':
    writer = new CommaSeparatedTable(tableWriterOptions);
    break;
  case 'application/json':
    writer = new ChartData(tableWriterOptions);
    break;
  default:
    writer = new Writer({ format: outputFormat });
  }

  (dryrun || verbose) && console.error({
    options, writer,
    infile, informat, inputFormat,
    outfile, outformat, outputFormat});

  // Ensure infile exists
  if (!fs.existsSync(infile)) {
    console.error(`Input file "${infile}" not found.`);
    process.exit(1);
  }
  if (dryrun) process.exit(1);

  // Read the input file
  const inputData = fs.readFileSync(infile, 'utf8');

  parser.parse(inputData, (error, quad, prefixes) => {
    if (prefixes) {
      if (!noprefix) {
        writer.addPrefixes(prefixes);
      }
      verbose && console.error({prefixes});
    }
    if (quad) {
      if (isQuadPermitted(quad, options)) {
        writer.addQuad(quad);
        verbose && console.error({quad});
      } else {
        const reject = 'rejected';
        verbose && console.error({reject, quad});
      }

    } else if (error) {
      console.error('Error parsing input data:', error);
      process.exit(1);
    } else {
      // End of input; write the output
      writer.end((error, result) => {
        if (error) {
          console.error('Error writing output data:', error);
          process.exit(1);
        } else {
          if (outfile=='-') {
            console.log(result);
          } else {
            fs.writeFileSync(outfile, result);
          }
        }
      });
    }
  });
}

program
  .name('semconvert')
  .description(
    ['Converts between various RDF and RDF-star syntaxes such as'
     ,'  nq|nt|rdf|trig|ttl|ttl+star|trig+star|rdf+star'
     ,'and can also convert to'
     ,'  application/vnd.org-mode (.org)'
     ,'  application/json (.json)'
     ,'  text/csv (.csv)'
     ,'  text/tab-separated-values (.tsv)'
    ].join('\n'))
  .argument('<infile>', 'the input file')
  .argument('<outfile>', 'the output file (or - for stdout)')
  .option('-o, --outformat <OF>', 'the output format')
  .option('-i, --informat <IF>', 'the input format')
  .option('-v, --verbose', 'show details')
  .option('-n, --noprefix', 'do not output prefixes')
  .option('-d, --dryrun', 'show what will happen but do nothing')
  .option('-s, --stripUrls',
          'strip http://x.co/wtf#eg http://x.co/a/eg http://eg/ to eg')
  .option('--ds, --denySubjLike <RegEx...>', 'ignore subjects like')
  .option('--ps, --passSubjLike <RegEx...>', 'permit subjects like')
  .option('--dp, --denyPredLike <RegEx...>', 'ignore predicates like')
  .option('--pp, --passPredLike <RegEx...>', 'permit predicates like')
  .action(semconvert)
  .addHelpText('after', `
Examples:
     # input.ttl
     @prefix : <http://example.com/a/path/> .
     :S1 Pred1 1.0; :Pred2 2.0; :Pred3 "one" .
     :S2 Pred1 3.0; :Pred2 4.0; :Pred3 "two" .
     :S3 Pred1 5.0; :Pred2 6.0; :Pred3 "tre" .

  semconvert input.trig output.nq # nothing to stdout
    trivial conversion from TRIG to N-Quads

  semconvert --denySubjLike Mo 'C.*rly' -- Buddies.ttl noMoOrCurly.ttl
    convert Turtle to Turtle but skip subjects matching Mo or C.*rly
    guard special characters with ''
    use -- to force the end of option processing

  semconvert --stripUrls --outformat=org  input.ttl -
       |  |Pred1|Pred2|Pred3|
       |S1|  1.0|  2.0|  one|
       |S2|  3.0|  4.0|  two|
       |S3|  5.0|  6.0|  tre|
    generate Org-Mode table output, striping url ugliness

  semconvert --informat=ttl+star --outformat=trig  input.ttl -
    if the outfile is - (ie stdout) then explicit --outformat
    force the --informat if there is RDFstar content

  semconvert --denySubjLike S2 --denyPredLike Pred1 Pred3  \\
             --outformat=org --stripUrls input.ttl -
       |  |Pred2|
       |S1|  2.0|
       |S3|  6.0|
    Subj or Pred can be passed or denied by space-delimited RegExes

  semconvert --ps S2 --pp Pred1 Pred3 -oorg -s input.ttl -
       |  |Pred1|Pred3|
       |S2|  3.0|  two|
    Same as previous example but abbreviated and pass/deny inverted!
`);

program.parse();
